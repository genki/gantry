#!/usr/bin/ruby
require "fileutils"
require "socket"
require "uri"
require "net/https"
require "openssl"
require "json"
require "erb"
require "digest/md5"
require "thwait"

module Gantry
  module Etcd
    def etcd
      addr = URI(ENV['ETCD_ENDPOINT'])
      c = Net::HTTP.new addr.host, addr.port
    ensure
      c.read_timeout = nil
      c.use_ssl = true
      c.ca_file = ENV['ETCD_CAFILE']
      c.cert = load_cert ENV['ETCD_CERTFILE']
      c.key = load_key ENV['ETCD_KEYFILE']
      c.verify_mode = OpenSSL::SSL::VERIFY_PEER
    end

  private
    def load_cert(path) OpenSSL::X509::Certificate.new open(path).read end
    def load_key(path) OpenSSL::PKey.read open(path).read end
  end

  module Logger
    @@mutex = Mutex.new
    def log(msg) @@mutex.synchronize{STDOUT.puts msg} end
    def err(msg) @@mutex.synchronize{STDERR.puts msg} end
  end

  class Watch
    include Etcd
    include Logger

    KEY_TTL     = (ENV['KEY_TTL'] || 60*60).to_i
    REFRESH_TTL = (ENV['REFRESH_TTL'] || 30*60).to_i
    SKYDNS_ROOT = (ENV['SKYDNS_ROOT'] || '/skydns/local')

    def self.start
      Thread.start{new}
    end

    def initialize
      if KEY_TTL < REFRESH_TTL
        raise 'KEY_TTL should be larger than REFRESH_TTL'
      end
      @services = {}
      @mutex = Mutex.new
      refresh
      Thread.start{loop{sleep REFRESH_TTL; refresh}}
      socket = UNIXSocket.new '/tmp/docker.sock'
      get socket, '/events' do |chunk,i|
        event chunk if i > 1
      end
    rescue Exception => e
      STDERR.push "error: #{e} try to restart..."
      retry
    ensure
      socket.close
    end

  private
    def refresh
      log "gantry refresh at #{Time.now}"
      s = UNIXSocket.new '/tmp/docker.sock'
      get s, '/containers/json', 'Connection' => 'Close' do |chunk,i|
        next if i == 1
        hdr,json,_ = chunk.split "\n"
        return JSON.load(json).each do |c|
          @mutex.synchronize{add c['Id']} if c["Ports"]
        end
      end
    ensure
      s.close
      @mutex.synchronize{cleanup} if ENV['CLEANUP']
    end
    
    def cleanup
      log "gantry cleanup"
      res = etcd.get "/v2/keys?recursive=1"
      etcd_rm = ->(key) do
        log "etcd rm #{key}"
        etcd.delete "/v2/keys#{key}?recursive=1"
      end
      node = ->(n) do
        if n["dir"]
          n["nodes"].map{|i| node[i]}.inject(&:+).tap do |count|
            etcd_rm[n["key"]] if count == 0
          end
        elsif (v = JSON.load n['value'] rescue nil)
          if @services[v["ID"]]; 1
          else etcd_rm[n["key"]]; 0
          end
        else etcd_rm[n["key"]]; 0
        end
      end
      node[JSON.load(res.body)["node"]]
    rescue Exception => e
      err "Failed to cleanup #{e}"
    end

    def event(chunk)
      id, json = chunk.split "\n", 2
      msg = JSON.load json
      case msg['status']
      when 'start'; @mutex.synchronize{add msg['id']}
      when 'die'; @mutex.synchronize{rm msg['id']}
      when 'stop','kill'; @mutex.synchronize{rm msg['id']}
      end
    rescue Exception => e
      STDERR.puts "Invalid event: #{e} json=#{json}"
    end

    def get(s, path, opts={}, chunk='', count=0, &block)
      req = Net::HTTP::Get.new path, opts
      req.exec s, '1.1', path
      while line = s.gets
        if line == "\r\n"
          block[chunk, count += 1]
          chunk = ''
        else chunk << line
        end
      end
    end

    def get_attrs(c, attrs={})
      env = c["Config"]["Env"]
      env.grep %r{^SERVICE_([^=]*)=(.*?)$} do |k|
        attrs[$1.tr 'A-Z_', 'a-z-'] = $2
      end
      attrs
    end

    def host_ip
      addrs = Socket.getaddrinfo Socket.gethostname, 0, Socket::AF_INET
      addrs.first[3]
    end

    BASE62_KEYS = 'abcdefghijklmnopqrstuvwxyz' +
      'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '0123456789'
    def base62x_encode(blob)
      num = blob.unpack('C*').inject{|s,i| s*256+i}
      out = BASE62_KEYS[num%52]
      num /= 52
      while num > 0
        out = BASE62_KEYS[num%62] + out
        num /= 62
      end
      out
    end 

    def each_entries(c, &block)
      net = c["NetworkSettings"]
      net_id = base62x_encode [net['NetworkID']].pack 'H*'
      net["Ports"].each do |k,v|
        src_port, proto = k.split '/', 2
        next if v.nil?
        v.each do |a|
          ip = a["HostIp"]
          ip = host_ip if ip == '0.0.0.0'
          dst_port = a["HostPort"]
          block[net_id, ip, src_port, dst_port, proto]
        end
      end
    end

    def add(cid)
      c = @services[cid]
      now = Time.now
      return if c && now - c['GantryRefreshedAt'] < REFRESH_TTL
      c = inspect cid
      c['GantryRefreshedAt'] = now
      attrs = get_attrs c
      name = attrs.delete 'name'
      return unless name
      log "gantry add #{name} (#{cid[0...12]})"
      tags = attrs.delete('tags') || ''
      each_entries c do |net_id, ip, sp, dp, proto|
        key = "#{net_id}-#{dp}"
        value = {
          'Key' => key,
          'ID' => cid,
          'Name' => name,
          'IP' => ip,
          'Port' => dp,
          'Tags' => tags.split(','),
          'Attrs' => attrs,
        }
        path = "#{name}/#{proto}-#{sp}/#{key}"
        log "+ #{path}"
        # add to etcd
        req = Net::HTTP::Put.new "/v2/keys/#{path}"
        req.form_data = {'value' => JSON.dump(value), 'ttl' => KEY_TTL}
        etcd.request req
        # add to skydns2
        names = [name, "#{proto}-#{sp}", attrs['machine'], attrs['node'], key]
        path = "/v2/keys#{SKYDNS_ROOT}/skydns/" + names.compact.join('/')
        req = Net::HTTP::Put.new path
        value = {
          'ID' => cid,
          'host' => ip,
          'port' => dp.to_i,
        }
        if priority = attrs['priority']
          value['priority'] = priority
        end
        req.form_data = {'value' => JSON.dump(value), 'ttl' => KEY_TTL}
        etcd.request req
      end
      @services[cid] = c
    rescue Exception => e
      err "#{e.message}\n#{e.backtrace.join "\n"}"
    end

    def rm(cid)
      return unless c = @services[cid]
      attrs = get_attrs c
      return unless name = attrs.delete('name')
      log "gantry rm #{name} (#{cid[0...12]})"
      each_entries c do |net_id, ip, sp, dp, proto|
        key = "#{net_id}-#{dp}"
        path = "#{name}/#{proto}-#{sp}/#{key}"
        log "- #{path}"
        etcd.delete "/v2/keys/#{path}"
        names = [name, "#{proto}-#{sp}", attrs['machine'], attrs['node'], key]
        etcd.delete "/v2/keys/#{SKYDNS_ROOT}/skydns/" + names.compact.join('/')
      end
      @services.delete cid
    rescue Exception => e
      err "#{e.message}\n#{e.backtrace.join "\n"}"
    end

    def inspect(cid)
      s = UNIXSocket.new '/tmp/docker.sock'
      path = "/containers/#{cid}/json"
      get s, path, "Connection" => "Close" do |chunk,i|
        next if i == 1
        hdr,json,_ = chunk.split "\n"
        return JSON.load json
      end
    ensure
      s.close
    end
  end

  class Server
    include Etcd
    include Logger

    def initialize(s)
      @socket = s
      @tmpl = ''
      @backends = []
      @values = {}
      @params = {}
    end

    def start
      recv_tmpl
      scan_backends
      wait_etcd if @mode == 'watch'
      fetch_etcd
      gen_conf
    end

  private
    def recv_tmpl
      nlines, nparams, @mode = @socket.gets.chomp.split ' ', 3
      log "#{nlines} line(s) #{nparams} param(s) #{@mode} mode"
      nparams.to_i.times do
        k,v = @socket.gets.chomp.split "=", 2
        @params[k.sub(/^GANTRY_/, '').downcase] = v
      end
      nlines.to_i.times{@tmpl << @socket.gets}
      log "received template"
    end

    class Else
      def initialize(cond) @cond = cond end
      def else(&block) block.call unless @cond end
    end

    class Scanner
      def initialize(tmpl, params, &block)
        @params, @block = params, block
        ERB.new(tmpl,nil,'-').result binding
      end
      def backend(name) @block[name]; Else.new true end
      def param(key) @params[key] end
    end

    def scan_backends
      Scanner.new(@tmpl, @params){|name| @backends << name}
      log "found #{@backends.size} backend(s)"
    end

    def wait_etcd
      threads = @backends.map do |name|
        Thread.new do
          begin
            etcd.get "/v2/keys/#{name}?recursive=1&wait=1"
          rescue Timeout::Error => e
            log "[W] wait_etcd: #{e}. retry"
            sleep 1
            retry
          rescue Exception => e
            err "[E] wait_etcd: #{e}"
            raise e
          end
        end
      end
      ThreadsWait.new(*threads).next_wait unless threads.empty?
      threads.each(&:exit).each(&:join)
      log "wait done"
    end

    def fetch_etcd
      threads = @backends.map do |name|
        Thread.new do
          begin
            res = etcd.get "/v2/keys/#{name}?sorted=1&recursive=1"
            [name, res.body]
          rescue Exception => e
            err "[E] fetch_etcd: #{e}"
            raise e
          end
        end
      end
      threads.each &:join
      threads.each do |t|
        name, body = t.value
        @values[name] = body
      end
      log "all values are fetched"
    end
    
    Service = Struct.new :key, :name, :ip, :port, :tags,
      :machine, :node, :priority, :attrs

    class Generator
      def initialize(params, &block) @params, @block = params, block end
      def run(tmpl) ERB.new(tmpl,nil,'-').result binding end
      def param(key) @params[key] end
      def backend(name, &block)
        backends = @block[name]
        backends.each do |n|
          s = Service.new n["ID"], n["Name"], n["IP"], n["Port"],
            n["Tags"], n["Attrs"]["machine"], n["Attrs"]["node"],
            n["Attrs"]["priority"], n["Attrs"]
          s.instance_eval &block
        end if backends
        Else.new(backends && !backends.empty?)
      end
    end

    def gen_conf
      conf = Generator.new @params do |name|
        values = JSON.load @values[name] rescue nil
        nodes = values["node"]["nodes"] rescue nil
        nodes.map{|node| JSON.load node["value"]} if nodes
      end.run @tmpl
      @socket.puts Digest::MD5.hexdigest conf
      @socket.puts conf
    end
  end
end

GANTRY_ROOT = ENV['GANTRY_ROOT'] || '/var/lib/gantry'
GANTRY_SOCKET = File.join GANTRY_ROOT, 'socket'
FileUtils.cp '/gantry/client', GANTRY_ROOT rescue nil
FileUtils.rm_f GANTRY_SOCKET
STDOUT.sync = true
STDERR.sync = true
UNIXServer.open GANTRY_SOCKET do |unix|
  STDOUT.puts "gantry server started"
  at_exit{FileUtils.rm_f GANTRY_SOCKET}
  Signal.trap(:INT){exit}
  Signal.trap(:TERM){exit}
  Gantry::Watch.start
  loop do
    Thread.start unix.accept do |s|
      begin
        STDOUT.puts "connected"
        Gantry::Server.new(s).start
        STDOUT.puts "disconnected"
      rescue Exception => e
        STDERR.puts "[E] #{e}\n#{e.backtrace*"\n"}"
      ensure
        s.close
      end
    end
  end
end
